---
layout: default
title: $E000-$FFFF - Kernal Rom, Standard Commodore Jump Table
---
# $E000-$FFFF - Kernal Rom, Standard Commodore Jump Table

# Kernal ROM

<a name="F890"></a>

## 63632 $F890 BOOT_CALL

<span class="badge badge-info">Has a jump table entry at [$FF53](#FF53)</span>

<a name="FF47"></a>

## 65351 $FF47 JSPIN_SPOUT

<span class="badge badge-info">Entry point for the SPIN_SPOUT routine, currently at [$E5FB](#E5FB)</span>

Sets up the serial bus for fast communications mode.

### Input

* Carry bit
  * clear to establish fast serial input
  * set to establish fast serial output

<a name="FF4A"></a>

## 65354 $FF4A JCLOSE_ALL

<span class="badge badge-info">Entry point for the CLOSE_ALL routine, currently at [$F23D](#F23D)</span>

Closes all files currently opened to a specified device.

### Input

* .A must contain the device number

### Output

* Carry bit
  * clear if all files have been successfully closed
  * set in case of error

<a name="FF4D"></a>

## 65357 $FF4D JC64_MODE

<span class="badge badge-info">Entry point for the C64_MODE routine, currently at [$E24B](#E24B)</span>

Switches immediately to 64 mode.

<a name="FF53"></a>

## 65363 $FF53 JBOOT_CALL

<span class="badge badge-info">Entry point for the BOOT_CALL routine, currently at [$F890](#F890)</span>

Routine needs parameter to be set:

* .X must hold device number
* .A must hold the character code corresponding to the desidered drive number (for ex. you should use $30 which corresponds to 0)

If the specified drive is not present or turned off, or the disk does not contain valid boot sectors, the routine will return carry bit set.

BOOT_CALL routine at [$F890](#F890) attempts to load and execute the boot sector from an auto-boot disk in the given drive and device. The BOOT protocol is as follows:

* Close all open files on boot device.
* Read track 1 sector 0 into TBUFFR ($B00).
* Check for auto-boot header, RTS if not.
* If (blk# > 0), BLOCK READ sequential sectors into RAM at given (adrl, adrh, bank) location.
* If LEN(filename) > 0, LOAD file into RAM-0 (normal load).
* JSR to user code at location C above.

On any error, the BOOT operation is aborted and the UI command is issued to the disk. A return may or may not be made to the caller depending upon the completion status and the BOOTed code. The BOOT sector has the following layout:

|$00|$01|$02|$03|$04|$05|$06||A||B|C|
|-|-|-|-|-|-|-|-|-|-|-|-|
|C|B|M|adrl|adrh|bank|blk#|title|0|filename|0|code|

<pre>
where: A = $07 + LEN(title)
       B =   A + LEN(filename)
       C =   B + 1
</pre>

The following examples illustrate the flexibility of this layout. This loads and runs a BASIC program:

<pre>
$00 -> "CBM"
$03 -> $00, $00, $00, $00 // no other BOOT sector
$07 -> "NAME",$00         // message "NAME" (+ terminator A)
$0C -> $00                // no filename (only terminator B)
$0D ->                    // code
  $A2, $13,               // LDX #$13
  $A0, $0B,               // LDY #$0B
  $4C, $A5, $AF           // JMP $AFA5 (J_EXECUTE_A_LINE)
$14 -> RUN"PROGRAM"       // BASIC statement
$20 -> $00                // empty code (C)
</pre>

This results in the message Booting NAME... being displayed and, utilizing a C128 BASIC jump table entry that finds and executes a BASIC statement, loads and runs the BASIC program named "PROGRAM". The same header can be used to load and execute a binary (machine code) program by simply changing RUN to BOOT.

While the file auto-load feature of the boot header could be used to load binary files simply by furnishing a filename, to execute it you must know the starting address and JMP to it. BASIC's BOOT command does that, and allows a more generic mechanism. In the next example, a menu is displayed and you are asked to select the operating mode. Nothing else is loaded in this "configure"-type header:

<pre>
$00 -> "CBM"
$03 -> $00, $00, $00, $00   // no other BOOT sector
$07 -> $00                  // no message (only terminator A)
$08 -> $00                  // no filename (only terminator B)
$09 ->                      // code (C)
  $20, $7D, $FF,            // JSR $FF7D (JPRIMM)
  $0D, $53, $45, $4C, $45,  // String start
  $43, $54, $20, $4D, $4F,
  $44, $45, $3A, $0D, $0D,
  $20, $31, $2E, $20, $43,
  $36, $34, $20, $20, $42,
  $41, $53, $49, $43, $0D,
  $20, $32, $2E, $20, $43,
  $31, $32, $38, $20, $42,
  $41, $53, $49, $43, $0D,
  $20, $33, $2E, $20, $43,
  $31, $32, $38, $20, $4D,
  $4F, $4E, $49, $54, $4F,
  $52, $0D, $0D, <b>$00</b>,      // String ends with $0D
  $20, $E4, $FF, $C9, $31,
  $D0, $03, $4C, $4D, $FF,
  $C9, $32, $D0, $03, $4C,
  $03, $40, $C9, $33, $D0,
  $EB, $4C, $00, $B0
</pre>

Starting from $09, the first three bytes stands for

<pre>
JSR $FF7D
</pre>

which is a jump to [$FF7D](E000#FF7C) (JPRIMM). It prints on screen the
string of character codes immediately following the JSR.

So, the code above shows this message and waits for a key press:

<pre>
SELECT MODE:

 1. C64 BASIC
 2. C128 BASIC
 3. C128 MONITOR
</pre>

The code after the string (starting with $20 after the $00 in bold):

<pre>
0000  20 E4 FF             JSR $FFE4
0003  C9 31                CMP #$31   // Key code 1
0005  D0 03                BNE $000A (*+3)
0007  4C 4D FF             JMP $FF4D  // Jump to JC64_MODE
000A  C9 32                CMP #$32   // Key code 2
000C  D0 03                BNE $0011 (*+3)
000E  4C 03 40             JMP $4003  // Jump to JSOFT_RESET
0011  C9 33                CMP #$33   // Key code 3
0013  D0 EB                BNE $0000 (*-15)
0015  4C 00 B0             JMP $B000  // Jump to JMONINIT
</pre>

The loading of sequential sectors is designed primarily for specialized applications (such as CP/M or games) that do not need a disk directory entry.

<a name="FF68"></a>

## 65384 $FF68 JSETBNK

<span class="badge badge-info">Entry point for the SETBNK routine, currently at [$F73F](#F73F)</span>

Establishes the current bank from which the data will be read or to which data will be written during load/save operation, as well as the bank where the filename for the I/O operations can be found.

### Input

* .A must contain the bank number for the data
* .X must contain the bank number for the filename

<a name="FF71"></a>

## 65393 $FF71 JJMPFAR

<span class="badge badge-info">Entry point for the JMPFAR routine, currently at [$02E3](0000#02E3)</span>

Jumps to a routine in a specified bank with no return to calling bank.

### Input

* Location $02 must contain the bank of the target routine.
* Location $03-$04 must contain the address of the target routine ($03 hi-byte, $04 lo-byte)
* Location $05 must contain the status register value when the target routine is reached
* Location $06 must contain the .A register value when the target routine is reached
* Location $07 must contain the .X register value when the target routine is reached
* Location $08 must contain the .Y register value when the target routine is reached

### Output

* Status register filled with location $05
* .A filled with location $06
* .X filled with location $07
* .Y filled with location $08

### Example

``` Assembly
  STA	$06     // .A, .X and .Y
  STX	$07	    // should be already filled
  STY	$08
  PHP         // Push status register to stack
  PLA         // Pull status register from stack to .A
  STA	$05     // Store status register to $05

  LDA	#1	    // Suppose to call $2000 in bank 1
  STA	$02
  LDX	#$00
  STX	$04
  LDY	#$20
  STY	$03

  JSR	$FF6E   // JJMPFAR

  LDA	$05	    // Restore status and registers
  PHA
  LDA	$06
  LDX	$07
  LDY	$08
  PLP
```

<a name="FFBA"></a>

## 65466 $FFBA JSETLFS

<span class="badge badge-info">Entry point for the SETLFS routine, currently at [$F7E8](#F7E8)</span>

Assigns the logical file number, device number and secondary address for an I/O operation.

### Input

* .A must contain the logical file number
* .X must contain the device number
* .Y must contain the secondary address

<a name="FFBD"></a>

## 65469 $FFBD JSETNAM

<span class="badge badge-info">Entry point for the SETNAM routine, currently at [$F731](#F731)</span>

Assigns the length and the address of filename for a I/O operation

### Input

* .A must contain the length of the filename
* .X must contain the lo-byte of the address of the first character of the filename
* .Y must contain the hi-byte of the address of the first character of the filename

If no name is used for this operation, load .A with 0 so .X .Y are irrelevant.

<a name="FFD5"></a>

## 65493 $FFD5 JLOAD

<span class="badge badge-info">Entry point for the LOAD routine, currently at [$F265](#F265)</span>

Loads or verifies a program file from tape or disk into a specified area of memory.

### Input

* JSETLFS at [$FFBA](#FFBA) must be called to establish device number and the secondary address.
* JSETNAM at [$FFBD](#FFBD) must be called to specify the length and the address of the filename
* JSETBNK at [$FF68](#FF68) must be called to specify the bank number where the filename can be found and the bank where the data is to be loaded
* .A must contain the operation type
  * 0 for load
  * !=0 for verify
* if bit 0 of the secondary address is 0, the file will be loaded starting at the address specified in .X (lo-byte) and .Y registers (hi-byte). It's called **relocation load**.
* if bit 0 of the secondary address is 1, the file will be loaded at the address specified in the file itself. It's called **absolute load**.

### Output

* Carry bit will be affected:
  * clear if data has been loaded succesfully
  * set in case of error or if RUN/STOP has been pressed and .A contains error code
    * .A could be 4 (file not found), 8 (no name specified), 9 (illegal device number specificied), 16 (load extended over address $FEFF).


### Example

``` Assembly
  LDA #FileNameLength
  LDX #FileName
  JSR $FFBD           // JSETNAM
  LDA #00
  TAX
  JSR $FF68           // JSETBNK
  LDA #00
  LDX #08
  LDY #01
  JSR $FFBA           // JSETLFS
  LDA #00
  JSR $FFD5           // JLOAD

  FileName: .text "FILENAME"
  .label FileNameLength = 8
```

<a name="FFD8"></a>

## 65496 $FFD8 JSAVE

<span class="badge badge-info">Entry point for the SAVE routine, currently at [$F53E](#F53E)</span>

Saves the contents of a block of memory to disk or tape.

### Input

* JSETLFS at [$FFBA](#FFBA) must be called to establish device number and the secondary address.
* JSETNAM at [$FFBD](#FFBD) must be called to specify the length and the address of the filename
* JSETBNK at [$FF68](#FF68) must be called to specify the bank number where the filename can be found and the bank where the data is to be saved
* .A must contain the address of zero-page pointer to the starting address to save
* .X must contain the lo-byte of the ending address plus 1 for the save
* .Y must contain the hi-byte of the ending address plus 1 for the save

### Output

* Carry bit will be affected:
  * clear if data has been loaded succesfully
  * set in case of error or if RUN/STOP has been pressed and .A contains error code
    * .A could be 5 (serial device was not present), 9 (illegal device number specificied).
