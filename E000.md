---
layout: default
title: $E000-$FFFF - Kernal Rom, Standard Commodore Jump Table
---
# $E000-$FFFF - Kernal Rom, Standard Commodore Jump Table

# Kernal ROM

In software engineering jargon, the collection of subroutines
that perform basic input and output functions for a computer
is referred to as the operating system kernel. The developers
of the kernel for the original Commodore PET spelled (or misspelled)
the term as kernal, and Commodore operating systems
have been referred to as the Kernal ever since. There are both
similarities and significant differences between the 128 Kernal
and the Kernals of earlier models.

The Kernal handles input from or output to five basic
sources: the keyboard, the video screen, the tape drive (Datassette),
the RS-232 port, and the serial bus (to which disk
drives and printers are connected). In the 128 Kernal, all keyboard
and video functions have been transferred to a separate
block of ROM, the screen editor, at [$C000](C000#C000).

Significant enhancements include the addition of an 80-
column screen, ESC-key screen-editing sequences, and keyboard table
pointers in RAM that make it easy to customize
the keyboard. Tape and RS-232 support is largely unchanged
from that provided in the Commodore 64 Kernal. Serial bus
operation is significantly enhanced by the addition of a new
fast serial mode which can transfer data much more quickly
than the old system, now fittingly referred to as slow serial
mode.

Additional new features of the 128 Kernal include routines
to handle the storage, retrieval, and comparison of data from
the various memory banks supported by the system, and support for DMA
(Direct Memory Access) transfer operations to
and from the 1700 and 1750 Memory Expansion Modules.

The heart of the Kernal is the collection of routines called
by the Kernal jump table at 65409-65525/$FF81-$FFF5. The
routines called from that table, and their supporting subroutines,
make up the bulk of the Kernal and provide access to
the majority of the 128's input/output (I/O) capabilities.
Almost any I/O operation can (and should) be performed
through the appropriate jump table entry. The Kernal jump
table has been a feature of all Commodore operating systems.

The 128 adds an additional jump table with 19 new entries at
65351-65407/$FF47-$FF7F. These entries provide access to
most of the 128 Kernal's new or enhanced features.

## 57344 $E000 RESET <a name="E000"></a>
### Performs main system initialization sequence
Resets the processor stack pointer to the top of the stack,
disables IRQ interrupts, and insures that the processor is not in
decimal mode; then sets the MMU configuration register for
bank 15. Other MMU registers are initialized from the table at
57419/$E04B. Next, the initialization status flag ([$0A04](0A00#0A04))
is reset to 0/$00 to indicate that all variables and vectors need
to be initialized. The interrupt and reset handling routines at
65285-65348/$FF05-$FF44 in Kernal ROM are copied to that
same area in all RAM banks, and the INDFET, INDSTA,
INDCMP, JSRFAR, JMPFAR, and DMA-CALL routines are
copied from the table at 63488/$F800 into bank 0 RAM.

Locations 65525-65527/$FFF5-$FFF7 in bank 1 are then
examined to see if they contain the character codes for the letters
CBM. If not, those locations are initialized with that character
pattern, and the soft reset vector at 65528/$FFF8 in bank
1 is initialized. However, if the test pattern is found (indicating
that RESET has already been performed at least once), the
routine jumps to the address in the vector. Normally, the vector
points to the routine at 57892/$E224, which simply
reinitializes the test pattern and vector. You can change the
address to add your own extra steps to the reset sequence.

The subroutine at 57922/$E242 is called to check for the
presence of a Commodore 64 cartridge. If one is detected, the
system is switched to 64 mode and the computer becomes a
Commodore 64. (You must press the RESET button or turn
the computer off and back on to return to 128 mode.) Otherwise,
the subroutine records the presence of any 128 function
ROMs in the table at 2753-2756/$0AC1-$0AC4. If a logged
function ROM is autostarting, its cold start routine is called. It
is possible that an autostarting ROM will retain control of the
system and will not return to complete the reset sequence.

Next, the IOINIT routine [$E109](#E109) is called to initialize the
video, CIA, and SID chip registers. The keyboard column
which includes the RUN/STOP and Commodore keys is
scanned. If RUN/STOP has been pressed, the Kernal memory
initialization flag (2562/$0A02) is checked. If the flag contains
a nonzero value, the following memory initialization step is
skipped. Since the flag is given the value 165/$A5 after the
first call to RAMTAS [$E093](#E093), zero-page values and memory
pointers are preserved if RUN/STOP is held down during a
subsequent reset. Otherwise, RAMTAS [$E093](#E093) is called to
clear all zero-page RAM locations and reestablish Kernal
pointers.

RESTOR [$E056](#E056) is called to load default Kernal indirect
vectors into 788-819/$0314-$0333. CINT [$C000](C000#C000) is called to
initialize the screen editor, after which IRQ interrupts are once
again allowed. If the RUN/STOP key has been pressed, the
monitor is entered through its cold start entry point [$B000](B000#B000). If
the Commodore key has been held down, 64 mode is entered
using the C64-MODE routine [$E24B](#E24B). Otherwise, BASIC 7.0
is entered via the restart vector at 2560/$0A00. If the
RAMTAS step has been performed, the restart vector will
point to BASIC's cold start entry point [$4000](4000#4000).

It is possible to perform most of the reset sequence without losing
the BASIC program currently in memory. Simply
hold down RUN/STOP while pressing the RESET button.
This will skip the RAMTAS step, which would wipe out important
program pointers. You will land in the monitor after
the reset; type X to exit to BASIC, where the current program
should still be intact.

Note that the reset routine does not explicitly attempt to
boot a disk or to initialize function ROMs that are not
autostarting. These tasks are performed by the Kernal PHOENIX routine
[$F867](#F867). In 128 ROM, PHOENIX is called only
during the BASIC cold start routine [$4023](4000#4023). However, as long
as the RUN/STOP or Commodore key is not held down, the
reset routine ends by jumping to the BASIC cold start routine,
so those actions are implicitly part of the normal reset
sequence.

## 57419 $E04B <a name="E04B"></a>
### Table of default MMU register settings
The 11 values in this table are copied into the MMU chip registers at
[$D500-$D50A](D500#D500) by the system reset routine [$E000](#E000).

## 57430 $E056 RESTOR <a name="E056"></a>
### Restores Kernal indirect vectors to their default values
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FF8A](#FF8A)</span>

Loads the X and Y registers with the value [$E073](#E073), the
address of the default vector table, then clears the status register
carry bit, and falls through into the following routine to
load default vector values.

## 57435 $E05B VECTOR <a name="E05B"></a>
### Loads or copies Kernal indirect vector values
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FF8D](#FF8D)</span>

Transfers the address value in the X and Y registers upon entry into a working
pointer (195-196/$C3-$C4). If the carry bit
is clear, 32 bytes starting at the specified address are copied to
the Kernal indirect vectors at 788-819/$0314-$0333. If carry
is set, the contents of the indirect vectors are copied to 32 locations starting
at the specified address. In either case, the target address must be visible
in bank 15.

## 57459 $E073 <a name="E073"></a>
### Table of default Kernal indirect vector values
The 16 two-byte values in this table are copied to the Kernal
indirect vectors (788-819/$0314-0$333) by the RESTOR routine [$E056](#E056),
part of the reset sequence.

## 57491 $E093 RAMTAS <a name="E093"></a>
### Initializes zero page and Kernal pointers
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FF87](#FF87)</span>

Sets all zero page RAM locations (2-255/$02-$FF) to 0/$00,
then initializes the cassette buffer pointer ([$B2-$B3](0000#B2))
to $0B00, the RS-232 input buffer pointer ([$C8-$C9](0000#C8))
to $0C00, and the RS-232 output buffer
pointer (202-203/$CA-$CB) to 3328/$0D00. The MEMSIZ
pointer (2567-2568/$0A07-$0A08) is set to 65280/$FF00
to mark the top of free RAM, and the MEMSTR pointer
(2565-2566/$0A05-$0A06) is set to 7168/$1C00 to mark the
bottom of free RAM in bank 0. The BASIC restart indirect vector
(2560-2561/$0A00-$0A01) is loaded with 16384/$4000,
the address of BASIC's cold start entry point. Finally, the
Kernal memory initialization flag ([$0A02](0A00#0A02)) is set to
165/$A5 to indicate that this routine has been performed.

## 57549 $E0CD <a name="E0CD"></a>
### Initializes all RAM-resident Kernal routines
Copies the interrupt- and reset-handling routines at
65285-65348/$FF05-$FF44 in Kernal ROM into the same addresses
in both RAM banks. These routines redirect interrupts
and reset to the proper handling routine in Kernal ROM (bank
15). It's necessary to have a copy in each bank, because an interrupt
or reset can occur while the system is configured for
any bank. The routines are actually copied into banks 0-3,
even though there isn't unique RAM in banks 2 and 3 in the
current 128.

Next, the code for the RAM-resident portions of vital indirect access
routines-INDFET [$02A2](0200#02A2), INDSTA [$02AF](0200#02AF),
INDCMP [$02BE](0200#02BE), JSRFAR [$02CD](0200#02CD), and JMPFAR [$02E3](0200#02E3)-is
copied from the table at 63488/$F800 into page 2 of the common area of
RAM. Finally, the code for the DMA-CALL execution routine [$03F0](0300#03F0)
is copied from [$F85A](#F85A) into page
3 of the common area of RAM.

## 57609 $E109 IOINIT <a name="E109"></a>
### Initializes I/O chip registers
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FF84](#FF84)</span>

Begins by disabling all interrupt sources on both CIA chips
and halting all CIA timers. All lines from the four CIA I/O
ports (ports A and B on both chips) are assigned their default
directions, input or output. Output lines are also assigned their
default states, high or low.
The direction and status of lines connected to the processor's
built-in I/O port are also established.

The VIC-II video chip's raster compare register is tested to
determine whether the raster line count ever reaches the value
264/$108. This indicates which video system, NTSC (North
American) or PAL (European), is being used. The video system depends
on the VIC-II chip currently installed. There are
separate versions for NTSC and PAL. The highest possible
raster line for an NTSC system is 263, so a value of 264 here
means that the system is using PAL. The NTSC/PAL flag
(2563/$0A03) is set accordingly-to 0/$00 for NTSC or
255/$FF for PAL. By designing the Kernal to adjust itself for
either system, Commodore's engineers avoided the need for
separate versions of the Kernal for North American and European 128s.

Next, a number of Kernal I/O flags are cleared: clock
mode storage ([$0A37](#0A37)), IRQ vector storage ([$0A0A](#0A0A)),
custom mode setting ([$0A3A](#0A3A)), and jiffy count compensation
(2614/$0A36). The keyboard (device 0) is made the
current input device (153/$99), and the screen (device 3) is
made the current output device (154/$9A).

VIC-II chip registers (53248-53296/$D000-$D030) are
initialized from the table at 58055/$E2C7, and 8563 video
chip registers are initialized using the subroutine at
57820/$E1DC. If the version number of the 8563 chip (bits
0-2 of the register at 54784/$D600) indicates that one of the
newer revisions of that chip is installed, the subroutine is
called again to adjust the horizontal scrolling register (R25). If
the PAL video system is in use, the subroutine is called yet
again to adjust vertical display registers (R4 and R7). Bit 7 of
the initialization status flag ([$0A04](0A00#0A04)) is tested. If the bit is
set to %1, IOINIT has been called at least once before, so the
following step, which sets up the 80-column character set, is
skipped. If the bit is %0 (as will normally be the case when
this routine is called as part of the reset sequence), the screen
editor INIT80 routine [$C027](C000#C027) is called to copy the ROM character
definitions into 8563 RAM. Then bit 7 of the initialization status
flag will be set to %1 to indicate that the step has
been performed.

All registers for the SID sound chip (54272-54296/
$D400-$D418) are cleared to zero to disable any sound output; then
VIC-II raster interrupts are enabled. The raster interrupt (set by
the default table value to occur at scan line 255) is
the normal source of jiffy IRQ interrupts for the 128. The fast
serial flag (2588/$0A1C) and RS-232 activity flag ($0A0F) are cleared
to zero. Timer B of CIA #1 is loaded with
65535/$FFFF and started counting continuously. Finally, a fast
serial mode setup sequence is performed.

## 57820 $E1DC <a name="E1DC"></a>
### Initializes 80-column video chip registers
Retrieves a byte from the position in the table at 58104/$E2F8
specified in the X register. The value is used as a register number
and the next value in the table is written to that 8563 register.
Once called, the routine repeatedly reads register
numbers and initializes registers until a value greater than
127/$7F is read for the register number. Normal X register
values upon entry are 0/$00 (to initialize the 8563), 59/$3B
(to adjust horizontal scrolling for different versions of the 8563
chip), or 62/$3E (to adjust register settings for a PAL video
system).

## 57840 $E1F0 <a name="E1F0"></a>
### Initializes or jumps through the soft reset vector
Examines the contents of locations 65525-65527/$FFF5-$FFF7
in bank 1 to determine whether those locations contain the
character codes for the letters CBM. If not, a branch is taken to
the following routine to initialize the test pattern and vector. If
the pattern is found, the reset vector has already been initialized,
so the address in the vector at 65528-65529/$FFF8-$FFF9
in bank 1 is loaded into locations 2-3/$02-$03. The routine
then takes an indirect jump to the specified address. (The system
will still be configured for bank 15, so the target routine
must in that bank.)

## 57892 $E224 <a name="E224"></a>
### Initializes the soft reset vector
Loads the system soft reset vector, locations 65528-65529/
$FFF8-$FFF9 in bank I, with the value 57892/$E224, the address
of this routine. Next, the character codes for the letters
CBM are copied to locations 65525-65527/$FFF5-$FFF7 in
bank 1 to indicate that the vector has been initialized.

## 57922 $E242 <a name="E242"></a>
### Checks for the presence of 64 cartridges or 128 function ROMs
Tests the GAME and EXROM lines from the memory expansion port
(reflected by bits 4 and 5 of the MMU mode configuration register at
54533/$D505). If either of the lines is
grounded, the routine falls through to enter 64 mode. Otherwise, a
branch is taken to the routine at 57963/$E26B to
check for 128 function ROMs.

## 57931 $E24B C64-MODE <a name="E24B"></a>
### Switches the system into 64 mode
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FF4D](#FF4D)</span>

Loads the processor data direction and I/O port registers
(locations 0-1/$00-$01) with their standard Commodore
64 settings, copies the reset routine from 57955-57962/
$E263-$E26A to 2-9/$02-$09, stores a zero in the clock rate
register (53296/$D030) to insure that the system is in slow (1
MHz) mode, then jumps to the reset-to-64 routine at 2/$02.
The short routine copied there stores the value 247/$F7 in the
MMU mode configuration register. Compared to the default
setting, that value clears bit 3 (prohibiting fast serial output)
and sets bit 6 (making 64 ROM visible while making 128
ROM and the MMU chip registers invisible). The routine then
initializes 64 mode by jumping through the hardware reset
vector (65532/$FFFC) in the now-visible Commodore 64 ROM.

## 57963 $E26B <a name="E26B"></a>
### Logs 128 function ROMs
Clears the function ROM ID table (2753-2756/$OACI-$OAC4),
then checks the seventh through ninth bytes beyond the starting
address in each of the four possible memory slots for function ROM:
32768/$8000 and 49152/$C000 in bank 8 for
external (cartridge) ROM, and 32768/$8000 and 49152/$C000
in bank 4 for internal ROM (in the free socket on the 128's
main circuit board). If the bytes are the character codes for the
letters CBM, a valid function ROM is present in the slot, and
the sixth byte beyond the starting address (the cartridge ID) is
retrieved and stored in the ID table. If the ID value is I, indicating an autostarting ROM, the starting address of the ROM
is loaded into the JSRFAR pointer (3-4/$03-$04), and JSRFAR
[$02CD] is used to call the ROM's cold start routine. (It is possible that the auto starting ROM will retain control of the system and not return.) ROMs that don't autostart are initialized
during the PHOENIX routine [$F867](#F867).

## 58052 $E2C4 <a name="E2C4"></a>
### Initialization test pattern
These three bytes are the character codes for the letters CBM,
used as a test pattern in various operations: testing whether
the soft reset vector has been initialized [$E1F0](#E1F0), checking for
128 function ROM [$E26B](#E26B), and checking for boot disks
[$F890](#F890).

## 58055 $E2C7 <a name="E2C7"></a>
### Table of default VIC chip register values
The 49 values in this table are copied to the VIC-II 40-column
video chip registers during the IOINIT routine [$E109](#E109) to establish
default register settings.

## 58104 $E2F8 <a name="E2F8"></a>
### Table of default 8563 chip register values
The first value in each two-byte table entry is the number of
the 8563 80-column video chip register into which the second
value is to be copied. The register settings are initialized by
the routine at 57820/$E1DC.

## 58171 $E33B TALK <a name="E33B"></a>
### Sends TALK command to a serial device
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FFB4](#FFB4)</span>
Sets bit 6 of the device number value in the accumulator to
%1 (the serial bus TALK command has the format %010nnnnn,
where %nnnnn is the number of the device being commanded
to talk). A BIT opcode is used to fall through into the next
routine to send the byte as a serial bus command.

## 58174 $E33E LISTEN <a name="E33E"></a>
### Sends LISTEN command to a serial device
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FFB1](#FFB1)</span>

Sets bit 5 of the device number value in the accumulator to %1
(the serial bus LISTEN command has the format %001nnnnn,
where %nnnnn is the number of the device being commanded
to listen). RS-232 activity is disabled. If a serial byte is awaiting
transmission in the buffer at 149/$95, it is sent with an
EOI (end-or-identify) handshake; then the command byte is
placed in the buffer.

The subroutine at [$E573](#E573) is used to disable IRQ interrupts and
standardize timing. Then the serial bus DATA
line is allowed to go high. If the serial bus ATN line is not
currently low, the routine attempts to establish fast serial
mode. It does this by setting the serial port for fast serial output
and sending out the value 255/$FF (eight %1 bits) using
the fast serial hardware. The port is then set for fast serial input
mode, and a short delay loop is executed. If a serial device
capable of fast serial communications is present, it should respond by
sending back a byte. This will cause a serial register
interrupt on CIA #1, which will be detected later to determine
that fast serial mode is available.

![Sending a Serial Command Byte](./resources/009-01-sending-a-serial-command-byte.png "Sending a Serial Command Byte")

1. 128 pulls ATN line low.
2. 128 pulls CLK line low and allows the DATA line to go high.
3. The external device must respond by holding the DATA line low.
If the DATA line is still high after approximately one millisecond,
it is assumed that the device is not present.
4. If the external device responded, the 128 allows the CLK line to
go high.
5. The external device must now allow DATA to go high again. (The
128 will wait indefinitely for this to happen.)
6. Once DATA goes high, the 128 responds by pulling the CLK line
low.
7. The command byte is then sent one bit at a time, starting with the
least significant bit (bit 0). Command bytes are always sent in
slow serial mode. To send a bit, the DATA line is set either low or
high, depending on whether the bit being sent is %0 or % 1. Then
the CLK is allowed to go high briefly to signal that a valid bit can
be read on the DATA line.
8. After the last data bit is sent, the 128 checks the DATA line. The
external device must pull that line low within approximately one
millisecond or a write-timeout error will be indicated.
9. The status of the ATN line after a command is sent depends on
the command. If it is TALK or LISTEN, ATN remains high so that
the secondary address can be sent as a command as well. However, ATN
is immediately pulled low following UNTALK and
UNLISTEN commands.

Next, the serial bus ATN line is pulled low to indicate
that the following byte will be a command. The serial bus
CLK line is pulled low, and the DATA line is allowed to go
high. A delay loop of approximately one millisecond is executed,
and the routine falls through into the following routine
to send the command byte.

Note that there is no corresponding routine for the 128
to receive a serial bus command. The 128 has no ATN input
line, so it cannot be commanded to listen (it only listens "voluntarily").
It must always be the only master device on the serial bus.

## 58252 $E38C <a name="E38C"></a>
### Sends buffered byte to a serial device
Begins by calling the subroutine at 58739/$E573 to disable
IRQ interrupts and standardize timing. If the system is set for
the fast (2 MHz) clock mode, it will be temporarily reset to the
normal (1 MHz) mode, which explains why serial communications are not
significantly affected by the clock mode.

The routine makes sure that the serial bus DATA line is
free to go high, then tests the state of the line. If the external
device is not holding DATA low, the device is considered not
present, so bit 7 of the serial status flag (144/$90) will be set
to %1, the ATN and CLK lines will be allowed to go high, and
the routine will exit. Otherwise, the routine will allow the CLK
line to go high. If bit 7 of the EOI flag (163/$A3) is set to %1,
the routine performs the EOI (end-or-identify) handshake by
waiting for the external device to set the DATA line high and
then low. Next, the routine waits for the external device to release
the DATA line to a high state. While it's waiting, the
routine checks whether a CIA #1 serial register interrupt has
occurred, indicating that a byte has been received via the fast
serial hardware. If so, the external device can accept fast serial
input, and the fast serial flag (2588/$OA1C) is set to 192/$C0
to indicate this.

Once the DATA line goes high, the routine immediately
pulls the CLK line low and proceeds to send the byte of data.
If fast serial mode is available, the process is simple: The serial
port is set for fast serial output, and the buffered byte from
149/$95 is stored in the CIA #1 serial data register ($DC0C).
After that, the transfer is automatic, handled by the
CIA chip hardware. The routine simply waits until a serial register
interrupt indicates that the byte has been completely sent,
then resets the port for fast serial input (its default state).

The process for sending a byte in standard (slow) serial
mode is more complicated because it is handled in software.
Bits are pulled from the buffered byte (149/$95), one at a
time, starting with the least significant bit (bit 0). For each bit,
the serial bus DATA output line is set either high or low, depending
on whether the bit to be sent is %0 or %1. Then the
CLK line is allowed to go high to signal to the external device
that a valid data bit can be read from the DATA line. After a
brief delay, the CLK line is pulled low, and the DATA line is
allowed to go high again. If the external device holds the
DATA line low between bits, a write-timeout occurs (the routine sets
bits 0 and 1 in the serial status flag to % 1, allows the
ATN and CLK lines to go high, and exits).

![Sending a Serial Data Byte](./resources/009-02-sending-a-serial-data-byte.png "Sending a Serial Data Byte")

1. The 128 allows the DATA line to go high. If the external device
does not continue to hold the line low, it is assumed that the
device is not present.
2. The 128 allows the eLK line to go high.
3. The external device must now allow DATA to go high. (The 128
will wait indefinitely for this to happen.)
4. Once DATA goes high, the 128 responds by pulling the eLK line
low.
5. The data byte is sent one bit at a time using either fast or slow
serial mode. To send a bit in slow serial mode (illustrated above),
the DATA line is set either low or high, depending on whether the
bit being sent is %0 or % 1. Then the eLK line is allowed to go
high briefly to signal that a valid bit can be read on the DATA
line. Fast serial mode works in a similar manner, except the transfer
is managed by CIA chip hardware rather than ROM software,
and the bits are clocked by pulses on the SRQ line rather than on
the eLK line.
6. After all of the byte is sent, the 128 checks the DATA line. The
external device must pull that line low within approximately one
millisecond, or a write-timeout error will be indicated.

After the byte has been sent (in either mode), the routine
waits for the external device to pull the DATA line low. If this
does not happen within approximately one millisecond, a
write-timeout occurs, and the routine sets bits 0 and 1 in the
serial status flag to %1, allows the ATN and CLK lines to go
high, and exits. Otherwise, the routine at [$E59F](#E59F) is used
to restore interrupts and the clock mode setting, then exits
with the status register carry bit clear. The Y register is unused
during the routine, and the X register value is preserved.

![Serial EOI Handshake](./resources/009-03-serial-eoi-handshake.png "Serial EOI Handshake")

1. As in a normal byte transfer, the external device must hold the
DATA line low or it will be assumed that the device is not
present.
2. The 128 allows the eLK line to go high.
3. The external device should then allow the DATA line to go high.
(The 128 will wait indefinitely for this to happen.)
4. When the 128 does not respond by pulling the eLK line low
within 200 microseconds, the external device should recognize
that an EOI handshake is being performed and should respond by
pulling DATA low again. (The 128 will wait indefinitely for DATA
to go low.)
5. The external device should then release DATA high again. The
128 will respond by pulling eLK low, and the final byte of the file
is then sent in the usual manner. (See steps 5-6 of Sending a Serial Data Byte)

## 58430 $E43E ACPTR <a name="E43E"></a>
### Reads a byte from a serial device
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FFA5](#FFA5)</span>
Begins by calling the subroutine at 58739/$E573 to disable
IRQ interrupts and standardize timing. If the system is set for
the fast (2 MHz) clock mode, it will be temporarily reset to the
normal (1 MHz) mode, which explains why serial communications are not
significantly affected by the clock mode. The routine insures that the
serial bus CLK line is free to go high,
then tests the state of the line and waits in a loop until it goes
high. Next, a delay counter is initialized, and the DATA line is
allowed to go high. If the external device responds by pulling
the CLK line low before the delay count expires, the routine
begins to process the incoming data bits. Otherwise, it assumes
that the external device is requesting an EOI (end-or-identify)
handshake. So the EOI bit (bit 6) of the serial status flag
(144/$90) is set to %1, and the DATA line is pulled low, then
allowed to go high again. The external device must acknowledge
the EOI handshake by pulling the CLK line low before
another delay period expires. If it doesn't, a read-timeout occurs,
and the routine sets bit 1 in the serial status flag to %1,
allows the ATN and CLK lines to go high, and exits.

If a serial register interrupt has occurred on CIA #1, a
byte has been received via the fast serial hardware. In this
case, the byte is retrieved from the serial data register
(56332/$DC0C) and stored in 164/$A4; then the fast serial
flag (2588/$0A1C) is reset to 192/$C0.

The process for receiving a byte in standard (slow) serial
mode is more complicated because it is handled in software.
The routine waits for the data line to go high and then for the
CLK line to go low. Then, when CLK goes high again, a bit is
read from the DATA line and shifted into the working byte
(164/$A4). The routine waits until CLK goes low before attempting
to read the next bit, and the process is repeated for
each of the eight bits of the byte.

After a byte has been received, the DATA line is pulled
low to mark the end of the frame. If the EOI handshake has
been performed, the CLK line is allowed to go high. The routine at
[$E59F](#E59F) is used to restore interrupts and the clock
mode setting. The routine exits with the status register carry
bit clear and with the received byte in the accumulator. The Y
register is unused during the routine, and the X register value
is preserved.

![Receiving a Serial Data Byte](./resources/009-04-receiving-a-serial-data-byte.png "Receiving a Serial Data Byte")

1. The 128 allows the CLK line to go high and waits for it to go high
if the external device is holding it low.
2. Once the CLK line goes high, the 128 allows the DATA line to go
high.
3. The 128 waits for the external device to respond by pulling the
CLK line low. If this hasn't happened after a delay of approximately 260 microseconds, the 128 assumes that an EOI handshake
is requested and briefly pulls the DATA line low. The external
device must respond by pulling CLK low before another 260-
microsecond delay expires; otherwise, a read-timeout error will
occur.
4. Once the CLK line goes low, the 128 prepares to read data. To receive
a bit in slow serial mode (illustrated above), the 128 waits
until the CLK line goes high, reads the CIA port bit connected to
the DATA input line, then waits for the CLK line to go low again.
Fast serial mode works in a similar manner, except the transfer is
managed by CIA chip hardware rather than ROM software, and
the bits are clocked by pulses on the SRQ line rather than the
CLK line.
5. After the byte is received, the 128 pulls the DATA line low to
indicate the end of the byte frame.
6. If the EOI handshake is performed, the CLK line is allowed to go
high after the byte is received.

## 58578 $E4D2 SECOND <a name="E4D2"></a>
### Sends secondary address after LISTEN
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FF93](#FF93)</span>

Stores the secondary address value from the accumulator into
the serial byte buffer at 149/$95, sends the buffered byte as a
command (the ATN line should still be high from the previous
LISTEN command), then falls through into the next routine to
allow the ATN line to go high again so that following bytes
will be seen as data instead of commands.

## 58583 $E4D7 <a name="E4D7"></a>
### Allows the serial bus ATN output line to go high
Forces bit 3 of CIA #1 port A to %0. Since that bit is connected
to the serial bus ATN output line via an inverter, this
will set the ATN output line to a high state (+5 volts).

## 58592 $E4E0 TKSA <a name="E4E0"></a>
### Sends secondary address after TALK
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FF96](#FF96)</span>

Stores the secondary address value from the accumulator into
the serial byte buffer at 149/$95, then sends the buffered byte
as a command (the ATN line should still be high from the
previous TALK command). If the device is not present, the
routine exits (after allowing the ATN and CLK lines to go high
again). Otherwise, the routine falls through into the next one
to make the 128 the listener and recognize the external device
as the talker.

## 58601 $E4E9 <a name="E4E9"></a>
### Performs talk-listen turnaround
Begins by calling the subroutine at 58739/$E573 to disable
IRQ interrupts and standardize timing. The DATA line is held
low, and the ATN line is allowed to go high (signaling the
end of the command). The CLK line is then allowed to go
high. The device which is commanded to talk should respond
by pulling CLK low. The routine waits for this to happen, then
jumps to the routine at 58783/$E59F to restore interrupts and
the clock mode.

![Talk-Listen Turnaround](./resources/009-05-talk-listen-turnaround.png "Talk-Listen Turnaround")

1. The 128 holds the DATA line low and allows the ATN line to go
high.
2. The 128 allows the eLK line to go high.
3. The external device must respond by pulling eLK low. (The 128
will wait indefinitely for this to happen.) The external device is
now the talker and the 128 is the listener.

## 58627 $E503 CIOUT <a name="E503"></a>
### Sends a byte to a serial device
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FFA8](#FFA8)</span>

Tests bit 7 of the serial buffer flag (148/$94). If the bit is %0,
indicating that the one-byte serial buffer (149/$95) is empty,
the byte in the accumulator is simply stored in the buffer and
the flag bit is set to % 1 before exiting. However, if the flag bit
is already %1, a character is currently waiting in the buffer. In
this case, the routine at 58252/$E38C is used to send the previously
buffered character before the new character is added to
the buffer. Carry will always be clear upon exit, and the byte
value will still be in the accumulator. The X and Y register values
are also preserved. The success of the operation can be determined from the
value in the serial status flag (144/$90).
The purpose of the buffering scheme is to make it possible to
perform the EOI (end-or-identify) handshake with the final
character of a file.

## 58645 $E515 UNTLK <a name="E515"></a>
### Sends UNTALK command to a serial device
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FFAB](#FFAB)</span>

Begins by calling the subroutine at [$E573](#E573) to disable
IRQ interrupts and standardize timing. The CLK line is pulled
low; then ATN is pulled low as well to indicate that the byte
will be a command. The accumulator is loaded with the UNTALK command value,
95/$5F. Then a BIT opcode is used to
fall through into the next routine to send the byte as a command. Unlike
TALK, which affects only a specified serial device, UNTALK affects all
serial devices. However, this shouldn't
cause problems because the 128 serial bus allows only one active talker
at any given time.

## 58662 $E526 UNLSN <a name="E526"></a>
### Sends UNLISTEN command to a serial device
<span class="badge badge-info">This routine has a Kernal jump table entry at [$FFAE](#FFAE)</span>

Loads the accumulator with the UNLISTEN command value,
63/$3F, then clears bit 7 of the serial mode flag ([$0A1C](#0A1C))
to disable fast serial mode, and sends the byte in the accumulator
as a command on the serial bus. Afterward, the ATN line
is allowed to go high (signaling the end of the command), and,
after a short delay, the CLK and DATA lines are allowed to go
high as well. Unlike LISTEN, which affects only a specified serial
device, UNLISTEN affects all serial devices. However, this
shouldn't cause problems because the 128 serial bus normally
has only one listener at any given time.

## 58693 $E545 <a name="E545"></a>
### Allows serial bus CLK output line to go high

Sets bit 4 of CIA #2 port A to %0. Since the output line for
that port bit is connected to the serial bus CLK output line via
an inverter, this will set the output line to a high state (+5
volts).

## 58702 $E54E <a name="E54E"></a>
### Pulls serial bus CLK output line low

Sets bit 4 of CIA #2 port A to %1. Since the output line for
that port bit is connected to the serial bus CLK output line via
an inverter, this will set the output line to a low state (0 volts).

## 58711 $E557 <a name="E557"></a>
### Allows serial bus DATA output line to go high

Sets bit 5 of CIA #2 port A to %0. Since the output line for
that port bit is connected to the serial bus DATA output line
via an inverter, this will set the output line to a high state
(+5 volts).

## 58720 $E560 <a name="E560"></a>
### Pulls serial bus DATA output line low
Sets bit 5 of CIA #2 port A to %1. Since the output line for
that port bit is connected to the serial bus DATA output line
via an inverter, this will set the output line to a low state (0
volts).

## 58729 $E569 <a name="E569"></a>
### Reads the serial bus DATA and eLK input lines
Reads the value at port A of CIA #2, then shifts the value of
bit 7, connected to the serial bus DATA input line, into the
status register carry bit. This will also shift the value of bit 6,
connected to the CLK input line, into bit 7. Upon return, the
DATA bit can be tested with BCC/BCS or shifted into a working byte,
and the CLK bit can be tested with BPL/BMI.

## 58739 $E573 <a name="E573"></a>
### Disables IRQ interrupts and standardizes timing during I/O operations
Begins by disabling IRQ interrupts. Next (at [$E574](#E574)), the
custom mode flag (2618/$0A3A) is checked. If bit 7 of this
flag is set to %1, the routine exits without changing the clock
mode setting or disabling sprites. The 128 sets this flag to zero
during the 10INIT routine (part of both the reset and
RUN/STOP-RESTORE sequences) and does not normally
change the value. You can set bit 7 of the flag if for some reason
you want to retain fast clock mode or sprites during an
I/O operation. The clock mode storage flag (2615/$0A37) is
then checked. The routine exits if bit 7 of this flag is set to
%1, indicating that a clock mode has already been stored (bits
2-7 of $D030 are always %1). Otherwise, the value in the
VIC-II register at 53296/$D030, which determines the system
clock frequency, is stored in the clock mode flag, and the
value in the register at 53269/$0015, which determines which
sprites are currently enabled, is stored in 2616/$OA38. Both
registers are then reset to zero, which disables all sprites and
sets the system to normal (1 MHz) clock speed. This is done to
standardize system timing. Tape and serial data transfers rely
on software delay loops for critical timing functions, so the
system must be in a standard mode for the loops to provide
the correct delay. If any sprites have previously been enabled,
a delay loop is executed before the routine exits.

## 58783 $E59F <a name="E59F"></a>
### Reenables interrupts and restores clock mode after I/O operations
Begins by checking the custom mode flag (2618/$0A3A). If bit
7 of this flag is set to % 1, the routine skips ahead to reenable
interrupts and exit. The 128 sets this flag to zero during the
IOINIT routine (part of both the reset and RUN/STOPRESTORE sequences)
and does not normally change the value.
You can set bit 7 of the flag if for some reason you want the
clock mode or sprite enable setting preserved after an I/O operation.
The clock mode storage flag (2615/$0A37) is then
checked. If bit 7 of this flag is set to %0, indicating that no
clock mode is stored, the routine skips ahead to reenable interrupts
and exit. Otherwise, the value in 2616/$0A38 is restored
to the VIC-II sprite enable register (53269/$D015), and the
value in 2615/$0A37 is restored to the clock mode register
(53296/$D030). The clock mode flag is then reset to zero. IRQ
interrupts are reenabled before exiting.

## 58812 $E5BC <a name="E5BC"></a>
### Performs fast serial turnaround
Waits for a serial register interrupt on CIA #1, indicating that
the current output byte has been completely sent, then falls
through into the next routine to reset the serial port lines for
fast serial input. The port is left set up for input so that incoming
fast serial communications can be detected automatically.

## 58819 $E5C3 SPIN <a name="E5C3"></a>
### Sets serial device for fast serial input
Sets the serial line from CIA #1 for input and halts timer A on
CIA #1; then clears bit 3 of the MMU register at 54533/$D505
to set the serial port's fast communications hardware for input.

## 58838 $E5D6 SPOUT <a name="E5D6"></a>
### Sets serial device for fast serial output
Sets bit 3 of the MMU register at 54533/$0505 to set the serial
port's fast communications hardware for output; then
clears all CIA #1 interrupts. Timer A is loaded with 4/$0004,
the timing constant for fast serial output bits. The serial line
for CIA #1 is set for output, and timer A is started. Bytes
subsequently stored in the serial data register of CIA #1 will be
sent via the fast serial hardware.

## 58875 $E5FB SPIN_SPOUT <a name="E5FB"></a>
### Sets serial device for fast serial input or output
Branches to one of the fast serial setup routines, depending on
the setting of the status register carry bit. If carry is clear, the
routine at [$E5C3](#E5C3) is used to set up the port for fast serial
input. If carry is set, the routine at [$E5D6](#E5D6) is used
to set up the port for fast serial output.

## 58879 $E5FF <a name="E5FF"></a>
### Prepares next bit for RS-232 transmission.
(Called by the NMI handling routine when a timer A interrupt
occurs.)
If the count of bits remaining to be sent is zero, indicating that
all stop bits for the current byte have been sent, a branch is
taken to 58954/$E64A to prepare the next byte for transmission.
If bit 7 of the count is set, a branch is taken to 58948/
$E644 to prepare to send a stop bit. Otherwise, the next bit to
be sent is pulled from the data byte storage (182/$B6) into the
carry bit, and the parity flag (189/$BD) is updated accordingly.
The count of remaining bits is decremented. If the result is zero,
a branch is taken to 58907/$E61B to prepare parity or stop
bits. Finally, bit 2 of 181/$B5 is set to the bit value to be sent.

## 58907 $E61B <a name="E61B"></a>
### Prepares parity and stop bits

Checks bit 5 of the RS-232 command register (2577/$OAll) to
determine whether a parity bit is to be sent. If not (if the bit is
%0), the routine skips ahead to determine the number of stop
bits. Otherwise, a parity bit is prepared. Bits 6 and 7 of the
command register determine the parity type. These are possible types:

|Bits 7-6|Parity type|
|-|-|
|0 0|Odd|
|0 1|Even|
|1 0|Mark|
|1 1|Space|

If odd parity is specified, the parity flag (189/$BD) is
tested. When the flag is nonzero, indicating that an odd number of
%1 bits has already been sent in the current byte, the
routine prepares a parity bit of %0. When the number of %1
bits already sent is even, a parity bit of %1 is prepared to
make the total odd. If even parity is specified, a parity bit of
%0 will be prepared when the parity flag indicates that the
number of %1 bits already sent is even, and a parity bit of % 1
will be prepared when the number of %1 bits sent is odd so
that the total number of %1 bits sent (including the parity bit)
will always be even. Mark and space parity are simpler: In the
former case, the parity bit is always %1; in the latter, it's always %0.
(Early versions of the Commodore 64 Kernal incorrectly computed
even and odd parity. All types of parity are
handled properly in the 128 Kernal and in the version of the
Commodore 64 Kernal used for 64 mode in the 128.)

Next, the routine prepares for the transmission of either
one or two stop bits, depending on the setting of bit 7 of the
RS-232 control register (2576/$0A10). If one stop bit is specified
(if the register bit is %0), the count of bits remaining to be
sent (180/$B4) is decremented once (to 255/$FF). If two stop
bits are sent (if the register bit is %1), the count is
decremented twice (to 254/$FE). The routine ends by branching back
into the previous routine to set the prepared parity or
stop bit as the next bit to send.

## 58948 $E644 <a name="E644"></a>
### Prepares to send a stop bit
Increments the count of bits remaining to be sent (180/$B4),
then prepares a %1 bit for transmission (stop bits are always
%1).

## 58954 $E64A <a name="E64A"></a>
### Prepares to transmit next byte
Checks bit 0 of the RS-232 command register (2577/$0A11) to
determine which handshaking mode is in use. If x-line
handshaking is specified (if the register bit is % 1), the RS-232
DSR and CTS lines (pins K and L of the user port) are tested.
If the external device is not holding these lines high, the
corresponding bit in the RS-232 status flag (2580/$0A14) is set -
bit 6 for DSR missing or bit 4 for CTS missing - then the
routine disables timer A interrupts to halt transmission.
For three-line handshaking, or for x-line handshaking
when DSR and CTS are held high, the parity flag (189/$BD)
is cleared and the current bit flag (181/$B5) is set to 0/$00
(start bits are always %0). The count of bits to send (180/$B4)
is loaded from 2581/$OA15. If the RS-232 output buffer is
empty, the routine disables timer A interrupts and exits.
Otherwise, the next available byte from the output buffer is
loaded into 182/$B6, and the pointer to the head of the buffer
(2586/$0A1A) is incremented.

## 59007 $E67F <a name="E67F"></a>
### Sets CIA interrupt register and RS-232 activity flag
Sets or clears bits in the interrupt control register for CIA #2,
depending on the value in the accumulator. If bit 7 of the
accumulator value is %0, the interrupt register bits corresponding
to the %1 bits in the accumulator value will be cleared. If
bit 7 is %1, the interrupt register bits corresponding to any
other %1 bits in the accumulator value will be set. The RS-232
activity flag (2575/$0A0F) is then updated to reflect the new
setting of the interrupt register.

## 59022 $E68E <a name="E68E"></a>
### Computes bit count for the RS-232 operation.
Computes a bit count based on the setting of bits 5 and 6 of
the RS-232 control register (2576/$0A10). The count value,
which will be one greater than the number of data bits specified,
will be returned in the X register.

|Bits 6-5|Data bits|Bit count|
|-|-|-|
|0 0|8|9|
|0 1|7|8|
|1 0|6|7|
|1 1|5|6|

## 59037 $E69D <a name="E69D"></a>
### Processes received bits

Checks the start bit flag (169/$A9) to determine whether the
start bit for a byte has been read yet. If not, a branch is taken
to 59092/$E6D4 to see whether this is a start bit. Otherwise,
the received bit count (168/$A8) is decremented. If the count
has reached zero, all bits for a byte have been received, so a
branch is taken to [$E6DF](#E6DF) to process the byte. Otherwise,
the parity indicator is toggled, and the received bit in
167/$A7 is shifted into the work byte (170/$AA).

## 59058 $E6B2 <a name="E6B2"></a>
### Tests for stop bit
Decrements the received bit count and checks whether the received
bit is a %1 (stop bits are always %1). If it is, bit 7 of
the RS-232 control register (2576/$0A10) is tested. If one stop
bit is specified (if the register bit is %0), the routine falls
through into the next one to prepare to receive the next byte.
If two stop bits have been specified, the routine exits to look
for another stop bit.

If a stop bit has not been received, the routine branches to
set a bit in the serial status flag (2580/$0A14) according to the
previously received byte (170/$AA): bit I-the framing error
bit-if the previously received byte is nonzero, or bit 7-the
break error bit-if the previously received byte is zero (indicating
that the received data line is being held low).

## 59074 $E6C2 <a name="E6C2"></a>
### Enables FLAG interrupts for CIA #1, then updates the RS-232
activity flag (2575/$0A0F) to indicate that FLAG interrupts are
active. The nonzero flag value will also be stored in the start
bit flag (169/$A9) to indicate that no start bit has been received.
Timer B interrupts are then disabled, and the activity
flag is updated to reflect this. (Timer B interrupts, used to time
incoming bits, are reenabled after the FLAG interrupt occurs.)

## 59092 $E6D4 <a name="E6D4"></a>
### Tests for start bit
Tests the received bit (in 167/$A7). If it is not %0, it is not a
start bit, so a branch is taken to 59074/$E6B2 to look for another
byte. Otherwise, the zero value is stored in the start bit
flag (169/$A9) to indicate that a start bit has been received,
and the parity indicator flag (171/$AB) is initialized to 1/$01.

## 59103 $E6DF <a name="E6DF"></a>
### Stores received character in buffer and checks parity
Checks whether space for an additional character is available
in the input buffer. If not, the routine branches to set the receiver
buffer overflow bit (bit 2) in the RS-232 status flag
(2580/$0A14) and to prepare for the reception of the next
byte. (The received character is lost in this case.) Otherwise,
the received character is padded with %0 bits if it is less than
eight bits long and then stored at the current tail of the input
buffer. If no parity is used, a branch is taken to 59058/$E6B2
to check for a stop bit. Otherwise, the current bit received
(167/$A7) is taken to be a parity bit and is compared against
the calculated parity for the byte. If the two do not correspond
to the specified parity type, the parity error bit (bit 0) of the
status flag will be set, and the routine will jump to reset for
the reception of the next byte.

## 59177 $E729 <a name="E729"></a>
### Handles CKOUT for RS-232 device
Sets the device number in the accumulator as the current output
device (154/$9A), then tests bit 0 of the RS-232 command
register (2577/$0A11). If the bit is %0, three-line handshaking
has been specified, so the routine exits at this point. For x-line
handshaking, the routine tests the DSR line (pin L of the user
port). If the external device is not holding this line high, a
branch is taken to set bit 6 of the RS-232 status flag (2580/
$0A14) and exit with the status register carry bit clear. If DSR
is high, the state of the RTS line (pin D of the user port) is
checked. If the 128 previously set this line high, the routine
exits with carry clear. Otherwise, the routine waits until any
current transmission is completed, then waits for the external
device to pull the CTS line (pin K of the user port) low. The
routine then sets the RTS line high to signal that it is ready to
send a byte and waits until an external device sets the CTS
line high to acknowledge that it is ready. (If DSR goes low
while the routine is waiting, bit 6 of the status flag will be
set). The routine then exits with carry clear.

## 59228 $E75C <a name="E75C"></a>
### Handles BSOUT for RS-232 device
Checks whether the output buffer is currently full. If no space
is available, the routine loops to enable interrupts for RS-232
transmission and waits until space becomes available in the
buffer. The buffer tail pointer (2587/$0A1B) is incremented,
and the value in the accumulator is placed at the tail of the
output buffer. If bit 0 of the RS-232 activity flag (2575/$0A0F)
is set to %1, timer A interrupts are already enabled, so the
routine exits at this point. Otherwise, timer A is loaded with
the bit timing constant value in 2582-2583/$0A16-$0A17;
then timer A interrupts are enabled, and the activity flag is
updated to reflect this. The routine at 58954/$E64A is called to
prepare to transmit the byte; then timer A is started.

## 59285 $E795 <a name="E795"></a>
### Handles CHKIN for RS-232 device
Sets the device number in the accumulator as the current input
device (153/$99), then tests bit 0 of the RS-232 command
register (2577/$0A11). If the bit is %0, three-line handshaking
has been specified, so the routine skips ahead to test whether
interrupts are enabled. For x-line handshaking, the routine
tests bit 4 of the command register to determine the duplex
mode in use. For full duplex (bit 4 is %0), the routine skips
ahead to test whether interrupts are available. For half duplex,
the RS-232 DSR line (pin L of the user port) is tested. If the
external device is not holding this line high, a branch is taken
to set bit 6 of the RS-232 status flag (2580/$0A14) and exit
with the status register carry bit clear. If DSR is high, the state
of the RTS line (pin 0 of the user port) is checked. If the 128
is currently holding this line high, the routine exits with carry
clear, then pulls the CTS line (pin K of the user port) low. The
routine then waits for DTR line to go high, after which FLAG
interrupts are enabled to detect the start bit.

The final step of the routine is to test whether FLAG or
timer B interrupts are enabled. If neither is enabled, FLAG
interrupts are enabled. The routine exits with carry clear.

## 59342 $E7CE <a name="E7CE"></a>
### Handles GETIN for RS-232 device
Checks whether any characters are available in the input
buffer. If so, bit 3 of the RS-232 status flag (2580/$0A14) is
cleared, the buffer head pointer (2585/$0A19) is incremented,
and the character from the buffer is returned in the accumulator.
If no characters are available, bit 3 of the status flag is
set to %1, and the value 0/$00 is returned in the accumulator.
The carry bit will be set in this case.

## 59372 $E7EC <a name="E7EC"></a>
### Disables RS-232 activity during tape or serial bus operations
Exits immediately if the RS-232 activity flag (2575/$0A0F)
contains the value 0/$00, indicating that no RS-232 operations
are being used. Otherwise, the routine waits until the transmission
or reception of the current byte is completed, then disables
FLAG interrupts so that no further bytes can be received
and clears the activity flag so that no more bytes will be sent.
The contents of the accumulator are preserved during this
routine.

## 59397 $E805 <a name="E805"></a>
### Handles NMI interrupts for RS-232
Controls the transmission and reception of data through the
RS-232 port. Three CIA #2 interrupt sources are used in RS-232
communications. Timer A is used to establish the duration of
bits being transmitted. The FLAG line, which triggers an interrupt
when it detects a high-to-Iow transition, is used to initiate
the reception of a byte when an incoming start bit is detected.
Timer B is used to time the reception of subsequent bits.

The routine begins by comparing the CIA #2 interrupt
register value at the time of the NMI interrupt (in the Y
register when the routine is called by the main NMI handler at
65285/$FF05) against the value in the RS-232 activity flag
(2575/$0A0F). If bit 0 is set in both, a valid timer A interrupt
has occurred to indicate that it is time to send the next bit. So,
the bit value (in bit 2 of 181/$B5) is written to bit 2 of CIA #2
port A, which is connected to the transmitted data line (pin M
of the user port). RS-232 interrupts are then reenabled by
writing the activity flag contents to the CIA interrupt register
(56589/$DD0D). In addition, the routine checks whether bit 1
or 4 is set in both the interrupt register value and the activity
flag, indicating that a valid FLAG or timer B interrupt occurred
concurrently with a timer A interrupt (RS-232 devices must be
capable of simultaneous transmission and reception). If neither
has occurred, the routine skips ahead to prepare the next bit
for transmission. For timer B interrupts, the subroutine at
59512/$E878 is called to read a bit. For FLAG interrupts, the
subroutine at 59561/$EA81 is called to start reception of a
byte. The subroutine at 58879/$E5FF is then called to prepare
the next bit for transmission. CIA interrupt sources are again
enabled before exiting.

If no timer A interrupt occurred, the routine checks
whether bit 1 is set in both the interrupt register value and the
activity flag, indicating that a valid timer B interrupt occurred.
If so, the subroutine at 59512/$E878 is called to read a bit.
Otherwise, a test is made of bit 4 in both the interrupt register
value and the activity flag. If the bit is set in both, a valid
FLAG interrupt has occurred, so the subroutine at 59561/
$E8A9 is called to start reception of a byte. In either case, the
activity flag value is stored in the CIA interrupt register to
reenable RS-232 interrupts before exiting.

## 59472 $E850 <a name="E805"></a>
### Table of baud rate timing constants for NTSC systems
The ten two-byte values in this table (in low-byte/high-byte
order) are the CIA timer settings used to transmit and receive
bits at the ten standard baud rates when the 128 is operating
with NTSC clock frequency (1.02273 MHz). This is the formula
for table values:
<pre>
value = 1.02273E6 / (2 * baud rate) - 100
</pre>

## 59492 $E864 <a name="E864"></a>
### Table of baud rate timing constants for PAL systems
The ten two-byte values in this table (in low-byte/high-byte
order) are the CIA timer settings used to transmit and receive
bits at the ten standard baud rates when the 128 is operating
with PAL clock frequency (0.985265 MHz). This is the formula
for table values:
<pre>
value = 0.985265E6 / (2 * baud rate) - 100
</pre>

## 59512 $E878 <a name="E878"></a>
### Reads a bit from RS-232 device
(Called by the NMI handling routine when a timer B interrupt
occurs.)
Reads the current status of the RS-232 received data line (pin
C of the user port) and stores the bit value in 167/$A7. The
interrupt time for the next bit is calculated and stored in the
timer B latch (56582-56583/$DD06-$DD07); then timer B is
restarted. CIA #2 interrupts are reestablished by storing the
RS-232 activity flag (2575/$0A0F) in the interrupt register
(56589/$DD0D), and the timer latch is reloaded with $FFFF.
The routine ends by jumping to 59037/$E69D to process the
received bit.

## 59561 $E8A9 <a name="E8A9"></a>
### Initiates reception of RS-232 byte
(Called by the NMI handling routine when a FLAG interrupt
occurs.)
Begins by copying the bit timing constant value (2578-2579/
$0A12-$0A13) into the latch for timer B (56582-56583/
$0006-$0007) and starting timer B. Then, FLAG interrupts
are disabled and timer B interrupts are enabled. The RS-232
activity flag (2575/$0A0F) is updated to reflect the change.
The latch for timer B is loaded with $FFFF so that the timer
will count continuously after it counts down for the next bit.
Finally, the count of bits to be received for the current
character is loaded from 2581/$0A15 into the working counter
(168/$A8).

## 59600 $E8D0 <a name="E8D0"></a>
### Reads next header block from tape
Calls the subroutine at 59890/$E9F2 to fill the cassette buffer
with the next block from tape, exiting with the status register
carry bit set if the RUN/STOP key is pressed while the block
is being loaded.

The first byte in the header block, the type identifier, is
then examined. If the identifier value is 5, this is an end-of-tape
marker, so the routine branches to exit with carry set (in
this case, the Y register will hold the value 255/$FF). If the
identifier value is something other than 1, 3, or 4, the routine
loops back to read another block. If Kernal messages are allowed,
FOUND is displayed, followed by 16 filename characters from the
buffer. (The buffer is filled with space characters
when the header is written, so the displayed name will be
padded with spaces if it is fewer than 16 characters long.) A
delay loop lasting for two increments of the middle byte of the
jiffy clock (161/$A1), about 8-1/2 seconds, is then started. If
the space key is pressed during this delay, the routine loops
back to the beginning to read another header. If any other key
in the same column (for example, Commodore or CONTROL)
is pressed, the loop is terminated. At the end of the loop, the
routine exits with carry clear. The X register will hold the type
identifier value for the header.

## 59673 $E919 <a name="E919"></a>
### Writes a header block to tape
Stores the type identifier value from the accumulator in 158/
$9E, then checks the address of the cassette buffer, exiting
immediately if it is less than 512/$0200. Otherwise, the contents
of the starting address pointer (193-194/$C1-$C2) and ending
address pointer (174-175/$AE-$AF) for the current operation
are stored on the stack, and the cassette buffer is filled
with space characters (32/$20). The type identifier value is
placed in the first byte of the buffer, and the starting address
and ending address values are placed in the next four bytes
(each in standard low-byte/high-byte order). The characters, if
any, of the current filename are then copied into the buffer
following the filename (the filename can fill the remainder of
the buffer, up to 187 characters). The buffer starting and
ending addresses are then set as the operation starting and ending
addresses; the leader flag (171/$AB) is loaded with 105/$69
for a long interfile leader; and the subroutine at 59932/$EA1C
is called to write the buffer contents to tape as a header. The
original starting and ending address pointer values are then
restored from the stack. Carry will be clear upon exit unless
the RUN/STOP key is pressed while the header is being
written.

## 59776 $E980 <a name="E980"></a>
### Loads and tests cassette buffer address
Loads the address value in the cassette buffer pointer (178-179/
$B2-$B3) into the X and Y registers; then compares the high
byte (in the Y register) with the value 2/$02 to test whether
the buffer address is greater than 511/$01FF. Upon exit, the
status register carry and Z bits will reflect the result of the
comparison.

## 59783 $E987 <a name="E987"></a>
### Sets buffer address as block address
Loads the address of the cassette buffer into the pointer to the
starting address of the block to be read or written (193-194/
$C1-$C2) and the ending address of the buffer (192 bytes beyond
the starting address) into the pointer to the end of the
block (174-175/$AE-$AF).

## 59802 $E99A <a name="E99A"></a>
### Searches for a specified header
Calls the routine at 59600/$E8D0 to load the next header
from tape into the cassette buffer; exits if carry is set
upon return from that routine (indicating that the RUN/STOP key has
been pressed or that an end-of-tape header has been read).
Characters from the current filename (pointed to by 187-188/
$BB-$BC in the bank specified in 199/$C7) are compared
against those in the buffer. If all characters match up to the
end of the current filename, the names are considered matching,
and the routine exits with carry clear, regardless of how
many characters may remain untested in the buffer (there's
nothing to indicate the length of the name read from tape).
However, if a mismatch is found, the routine loops back to
search for another filename.

## 59838 $E9BE <a name="E9BE"></a>
### Checks for cassette buffer filled or emptied
Calls the routine at 59776/$E980 to get the high byte of the
cassette buffer address into the X register. The buffer index
(166/$A6) is then incremented, loaded into the Y register, and
compared against the value 192/$C0, the maximum count of
characters in the buffer. Upon exit, the status register Z and
carry bits will reflect the result of the comparison (both will be
set if the end of the buffer is reached).

## 59848 $E9C8 <a name="E9C8"></a>
### equests PLAY button if necessary
Checks whether a tape button is currently pressed; exits with
the status register carry and Z bits set if any buttons are
already pressed. Otherwise, if Kernal messages are allowed,
PRESS PLAY ON TAPE is displayed. The routine then waits
for a tape button to be pressed. If the RUN/STOP key is
pressed in the meantime, the routine exits with the status
register carry bit set. When a button is pressed, the routine
displays OK (if messages are allowed) and exits.

## 59871 $E9DF <a name="E9DF"></a>
### Checks tape buttons
Tests the setting of bit 4 of the processor on-chip I/O port
(1/$01), connected to the cassette button sense line. The status
register Z bit will be clear if no button is pressed or will be set
if any button is detected.

## 59881 $E9E9 <a name="E9E9"></a>
### Requests RECORD and PLAY buttons if necessary
Checks whether a tape button is currently pressed; exits with
the status register carry and Z bits set if any buttons are already pressed. Otherwise, if Kernal messages are allowed,
PRESS RECORD & PLAY ON TAPE is displayed. The routine
then waits for a tape button to be pressed. If the RUN/STOP
key is pressed in the meantime, the routine exits with the status register carry bit set. When a button is pressed, OK is displayed (if messages are allowed) and the routine exits.

## 59890 $E9F2 <a name="E9F2"></a>
### Reads next header or data block from tape
Clears the tape status flag (144/$90) and operation flag
(147/$93) to zero; then sets the starting and ending addresses
of the cassette buffer as the starting and ending addresses for
the current operation and falls through into the next routine.

## 59899 $E9FB <a name="E9FB"></a>
### Reads or verifies a block from tape
Calls the subroutine at 59848/$E9C8 to request that the PLAY
button be pressed and exits (with carry set) if the RUN/STOP
key is pressed during that subroutine. IRQ interrupts are disabled,
and a series of variables and counters are initialized.
The accumulator is loaded with 144/$90 (the value to enable
FLAG interrupts), and the X register is loaded with 14/$0E
(the offset for read interrupts), and the routine branches to the
main tape I/O routine (59942/$EA26).

## 59925 $EA15 <a name="EA15"></a>
### Writes a header or data block to tape
Calls the subroutine at 59783/$E987 to set the buffer
addresses as the starting and ending addresses for the operation;
then falls through into the next routine to write the buffer
block to tape.

## 59928 $EA18 <a name="EA18"></a>
### Writes a block to tape
Loads the leader flag (171/$AB) with 20/$14 to specify a
short leader between the header and the block; then calls the
subroutine at 59881/$E9E9 to request that the PLAY and
RECORD buttons be pressed. (The routine will exit with carry
set if the RUN/STOP key is pressed during the subroutine.)
IRQ interrupts are disabled and the accumulator is loaded with
130/$82 (the value to enable timer B interrupts), and the X
register is loaded with 8/$08 (the offset to write leader bits).
The routine then falls through into the next one to perform
the operation.

## 59942 $EA26 <a name="EA26"></a>
### Initiates tape I/O operation.
Begins by disabling all VIC-II interrupt sources and clearing
any.pending VIC-II interrupts. The value in the accumulator
upon entry is loaded into the interrupt control register for CIA
#1 (56333/$DC0D), and timer B is started. Tape operations depend
on precise timing, so all other activities that affect system
timing are disabled: RS-232 interrupts are disabled, the 40-
column screen is blanked, and the subroutine at 58740/ $E574
is called to switch to standard (1 MHz) clock mode and disable
sprites. The current address in the IIRQ vector at 788-789/
$0314-$0315 is preserved in 2569-2570/$0A09-$0A0A; then
the subroutine at 61083/$EE9B is called to load a new value
into IIRQ, according to the value in the X register. This new
IRQ service routine will be responsible for reading or writing
data to tape. The count of blocks to be read or written (190/
$BE) is initialized to 2 (blocks are always read or written in
pairs). The subroutine at 60762/$ED5A is called to initialize
variables; then the tape motor is started, the interlock location
(192/$CO) is set to keep it on, and a delay loop is executed to
allow the motor to get up to normal speed. IRQ interrupts are
then enabled to begin the reading or writing process.

Since the actual tape operations are performed during IRQ
interrupts, the routine must now wait in a loop for the operation
to be completed. It continually tests the IRQ storage flag
(2570/$0A0A), waiting for the IIRQ vector to be reloaded with
the address stored there, which will happen after the IRQ-driven
tape routines are finished. In the meantime, the RUN/
STOP key is also tested. If that key is pressed, the operation is
halted and the routine exits with carry set. Otherwise, when
the original IIRQ address is restored at the end of the operation,
the vector storage flag will be reset to zero, and the routine will
exit with carry clear.

## 60047 $EA8F <a name="EA8F"></a>
### Checks for RUN/STOP keypress during tape operations
Calls the Kernal STOP routine [$FFE1] to determine whether
the RUN/STOP key has been pressed. If it has been, the cassette
motor is stopped, the default IIRQ vector address is restored,
the return address of the calling routine is removed
from the stack, and the IRQ vector storage flag (2570/$0A0A)
is cleared.

## 60065 $EAA1 <a name="EAA1"></a>
### Sets timer A to check for FLAG interrupts
The reception of tape dipole is normally initiated by a FLAG
interrupt from CIA #t which is triggered by the low-to-high
transition on the cassette read line at the start of a dipole.
Timer A of CIA #1 is loaded with a timing value for the type
of dipole being read, and it's used to check whether too much
time elapses between FLAG interrupts (which should be
equally spaced) in an attempt to determine whether any dipoles
might have been missed. If no FLAG interrupt occurs
before the timer counts down to zero, the timer will trigger an
interrupt. This prevents the 128 from waiting indefinitely for a
FLAG interrupt.

## 60139 $EAEB <a name="EAEB"></a>
### Reads or verifies a block of data from tape
(This is a tape IRQ service routine.)
Reads magnetic patterns (known as dipoles) from tape, assembles
them into bytes, and loads the bytes into memory (or
compares the bytes against memory) until a specified ending
address is reached. The routine for reading from tape is the
longest and most complex one in the Kernal, and will not be
discussed in detail here. For a thorough description of the
process, refer to COMPUTE's VIC-20 and Commodore 64 Tool Kit:
Kernal, by Dan Heeb.

Briefly, the routine reads dipoles from tape and determines
whether they represent leaders, word markers, or data
bytes. The routine does not demand that the dipoles have an
absolutely exact duration, but rather it employs a concept
known as an adjustable baseline to determine whether the dipole
is within an acceptable range for a particular type. This
makes it possible to compensate for minor variations in the
motor speed of different Datassette units. Because two complete
copies of the data block are recorded, error correction is
possible. If an error is detected while a byte is being read from
the first block, the address of the byte which could not be read
is recorded in page 1. Up to 31 error addresses can be recorded
in 256-317/$0100-$013D. When the second block is
read, the bytes can be corrected if no error is encountered
when the byte is read from that block.

When a byte is successfully read from tape, the handling
of the byte depends on the value in the operation flag (147/
$93). If the flag value is zero, the byte is stored in the location
pointed to by 172-173/$AC-$AD in the bank specified in
198/$C6. If the value is nonzero, the byte is compared against
the contents of the location pointed to by 172-173/$AC-$AD
in the bank specified in 198/$C6 (a verify operation).

Errors which cannot be corrected are recorded in the tape
status flag (144/$90). If the end of a block is reached before
the specified ending address (a short-block error), bit 2 of the
flag is set to % 1. If more than 31 errors occur while the first
block is being read, or if an error recorded during the first
block cannot be connected during the second block, an
unrecoverable-read error occurs, and bit 4 of the flag is set to %1.
That bit is also set during a verify operation if the byte in
memory doesn't match the corresponding byte in either block
on tape. If the byte read from tape as a checksum doesn't
match the calculated checksum for the bytes previously read
from tape, a checksum error occurs, and bit 5 of the flag is set
to %1.

## 60753 $ED51 <a name="ED51"></a>
### Loads working pointer with starting address
Transfers the starting address of the current block (193-194/
$C1-$C2) to the tape working pointer (172-173/$AC-$AD).

## 60762 $ED5A <a name="ED5A"></a>
### Initializes tape variables between each byte
Resets the count of bits for the next byte (163/$A3) to 8; then
clears the dipole flag (164/$A4), the word marker half-dipole
flag (168/$A8), the parity work byte (155/$9B), and the word
marker flag (169/$A9).

## 60777 $ED69 <a name="ED69"></a>
### Initiates writing of a tape half-dipole
Reads the bit value for the current half-dipole to be sent (the
current value of the rightmost bit in 189/$BD) and loads CIA
#1 timer B with the appropriate value: $0060 for a short halfdipole
if the bit is %0 or $OOBO for a long half-dipole if the bit
is % 1. The routine then clears the CIA interrupt register, starts
timer B, and toggles the cassette write line (bit 3 of the 8502's
on-chip I/O port at location 1/$01) to begin writing the current
half-dipole. Upon exit, the status register Z bit will be set
if the line is currently low or will be clear if the line is currently high.

## 60816 $ED90 <a name="ED90"></a>
### Writes a block of data to tape
(This is a tape IRQ service routine.)
Writes bytes of data from memory to tape until the specified
ending address is reached. The system used for representing
the bytes on tape is rather complex. Each bit of a byte is represented
by a magnetic pattern called a dipole, which is generated by holding
the cassette write line (bit 3 of the 8502's onchip I/O port at
location 1/$01) high for a period, then low
for a different period. The duration of the periods is determined
by the value loaded into CIA #1 timer B, which controls the amount
of time between IRQ interrupts for tape. The
routine at 60777/$ED69 actually writes each half of the dipole.
A %0 bit is represented by a short half-dipole followed
by a long one, while a % 1 bit is represented by a long
halfdipole followed by a short one. Each byte is preceded by a
word marker dipole, which consists of an extra-long word
marker half-dipole followed by a long half-dipole. Each byte is
followed by a parity bit dipole. The parity bit will be either
%0 or %1, as necessary to provide an odd total number of %1
bits in the byte and parity bit combined. The routine writes
two complete copies of the data block, separated by a short
leader. As each byte is written, it is also exclusive-ORed with
a checksum work byte. This checksum byte is written to tape
following the second copy of the block to provide an additional
error check. For a more thorough description of the process,
refer to COMPUTE!'s VIC-20 and Commodore 64 Tool Kit:
Kernal, by Dan Heeb.
