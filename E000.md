---
layout: default
title: $E000-$FFFF - Kernal Rom, Standard Commodore Jump Table
---
# $E000-$FFFF - Kernal Rom, Standard Commodore Jump Table

# Kernal ROM

<a name="F890"></a>

## 63632 $F890 BOOT_CALL

<span class="badge badge-info">Has a jump table entry at [$FF53](#FF53)</span>

<a name="FF53"></a>

## 65363 $FF53 JBOOT_CALL

<span class="badge badge-info">Entry point for the BOOT_CALL routine, currently at [$F890](#F890)</span>

Routine needs parameter to be set:

* .X must hold device number
* .A must hold the character code corresponding to the desidered drive number (for ex. you should use $30 which corresponds to 0)

If the specified drive is not present or turned off, or the disk does not contain valid boot sectors, the routine will return carry bit set.

BOOT_CALL routine at [$F890](#F890) which attempts to load and execute the boot sector from an auto-boot disk in the given drive and device. The BOOT protocol is as follows:

* Close all open files on boot device.
* Read track 1 sector 0 into TBUFFR ($B00).
* Check for auto-boot header, RTS if not.
* If (blk# > 0), BLOCK READ sequential sectors into RAM at given (adrl, adrh, bank) location.
* If LEN(filename) > 0, LOAD file into RAM-0 (normal load).
* JSR to user code at location C above.

On any error, the BOOT operation is aborted and the UI command is issued to the disk. A return may or may not be made to the caller depending upon the completion status and the BOOTed code. The BOOT sector has the following layout:

|$00|$01|$02|$03|$04|$05|$06||A||B|C|
|-|-|-|-|-|-|-|-|-|-|-|-|
|C|B|M|adrl|adrh|bank|blk#|title|0|filename|0|code|

<pre>
where: A = $07 + LEN(title)
       B =   A + LEN(filename)
       C =   B + 1
</pre>

The following examples illustrate the flexibility of this layout. This loads and runs a BASIC program:

<pre>
$00 -> "CBM"
$03 -> $00, $00, $00, $00 // no other BOOT sector
$07 -> "NAME",$00         // message "NAME"
$0C -> $00                // no filename
$0D ->                    // code
  $A2, $13,               // LDX #$13
  $A0, $0B,               // LDY #$0B
  $4C, $A5, $AF           // JMP $AFA5 (J_EXECUTE_A_LINE)
$14 -> RUN"PROGRAM"       // data (BASIC statement)
$20 -> $00
</pre>

This results in the message Booting NAME... being displayed and, utilizing a C128 BASIC jump table entry that finds and executes a BASIC statement, loads and runs the BASIC program named "PROGRAM". The same header can be used to load and execute a binary (machine code) program by simply changing RUN to BOOT.

While the file auto-load feature of the boot header could be used to load binary files simply by furnishing a filename, to execute it you must know the starting address and JMP to it. BASIC's BOOT command does that, and allows a more generic mechanism. In the next example, a menu is displayed and you are asked to select the operating mode. Nothing else is loaded in this "configure"-type header:

<pre>
$00 -> "CBM"
$03 -> $00, $00, $00, $00   // no other BOOT sector
$07 -> $00                  // no message
$0C -> $00                  // no filename
$0D ->                      // code
  $20, $7D, $FF,            // JSR $FF7D (JPRIMM)
  $0D, $53, $45, $4C, $45,  // String start
  $43, $54, $20, $4D, $4F,
  $44, $45, $3A, $0D, $0D,
  $20, $31, $2E, $20, $43,
  $36, $34, $20, $20, $42,
  $41, $53, $49, $43, $0D,
  $20, $32, $2E, $20, $43,
  $31, $32, $38, $20, $42,
  $41, $53, $49, $43, $0D,
  $20, $33, $2E, $20, $43,
  $31, $32, $38, $20, $4D,
  $4F, $4E, $49, $54, $4F,
  $52, $0D, $0D, <b>$00</b>,      // String ends with $0D
  $20, $E4, $FF, $C9, $31,
  $D0, $03, $4C, $4D, $FF,
  $C9, $32, $D0, $03, $4C,
  $03, $40, $C9, $33, $D0,
  $EB, $4C, $00, $B0
</pre>

Starting from $0D, the first three bytes stands for

<pre>
JSR $FF7D
</pre>

which is a jump to $FF7D (JPRIMM). It prints on screen the
string of character codes immediately following the JSR.

So, the code above shows this message and waits for a key press:

<pre>
SELECT MODE:

 1. C64 BASIC
 2. C128 BASIC
 3. C128 MONITOR
</pre>

The code after the string (starting with $20 after the $00 in bold):

<pre>
0000  20 E4 FF             JSR $FFE4
0003  C9 31                CMP #$31   // Key code 1
0005  D0 03                BNE $000A (*+3)
0007  4C 4D FF             JMP $FF4D  // Jump to JC64_MODE
000A  C9 32                CMP #$32   // Key code 2
000C  D0 03                BNE $0011 (*+3)
000E  4C 03 40             JMP $4003  // Jump to JSOFT_RESET
0011  C9 33                CMP #$33   // Key code 3
0013  D0 EB                BNE $0000 (*-15)
0015  4C 00 B0             JMP $B000  // Jump to JMONINIT
</pre>

The loading of sequential sectors is designed primarily for specialized applications (such as CP/M or games) that do not need a disk directory entry.
